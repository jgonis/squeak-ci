Object subclass: #ShootoutBody	instanceVariableNames: 'x y z vx vy vz mass'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutBody methodsFor: 'nbody'!addMomentumTo: anArray	anArray at: 1 put: (anArray at: 1) + (vx * mass).	anArray at: 2 put: (anArray at: 2) + (vy * mass).	anArray at: 3 put: (anArray at: 3) + (vz * mass).	^anArray! !!ShootoutBody methodsFor: 'nbody'!and: aBody velocityAfter: dt	| dx dy dz distance mag |	dx := x - aBody x.	dy := y - aBody y.	dz := z - aBody z.	distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.	mag := dt / (distance * distance * distance).	self decreaseVelocity: dx y: dy z: dz m: aBody mass * mag.	aBody increaseVelocity: dx y: dy z: dz m: mass * mag! !!ShootoutBody methodsFor: 'nbody'!decreaseVelocity: dx y: dy z: dz m: m	vx := vx - (dx * m).	vy := vy - (dy * m).	vz := vz - (dz * m)! !!ShootoutBody methodsFor: 'nbody'!increaseVelocity: dx y: dy z: dz m: m	vx := vx + (dx * m).	vy := vy + (dy * m).	vz := vz + (dz * m)! !!ShootoutBody methodsFor: 'nbody' stamp: 'eem 7/28/2008 12:44'!kineticEnergy	^0.5 * mass * ((vx * vx) + (vy * vy) + (vz * vz))! !!ShootoutBody methodsFor: 'nbody'!offsetMomentum: anArray	| m |	m := self class solarMass.	vx := (anArray at: 1) negated / m.	vy := (anArray at: 2) negated / m.	vz := (anArray at: 3) negated / m! !!ShootoutBody methodsFor: 'nbody'!positionAfter: dt	x := x + (dt * vx).	y := y + (dt * vy).	z := z + (dt * vz)! !!ShootoutBody methodsFor: 'nbody'!potentialEnergy: aBody	| dx dy dz distance |	dx := x - aBody x.	dy := y - aBody y.	dz := z - aBody z.	distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.	^mass * aBody mass / distance! !!ShootoutBody methodsFor: 'accessing'!mass	^mass! !!ShootoutBody methodsFor: 'accessing'!x	^x! !!ShootoutBody methodsFor: 'accessing'!x: d1 y: d2 z: d3 vx: d4 vy: d5 vz: d6 mass: d7	x := d1.	y := d2.	z := d3.	vx := d4.	vy := d5.	vz := d6.	mass := d7! !!ShootoutBody methodsFor: 'accessing'!y	^y! !!ShootoutBody methodsFor: 'accessing'!z	^z! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutBody class	instanceVariableNames: ''!!ShootoutBody class methodsFor: 'constants'!daysPerYear	^365.24! !!ShootoutBody class methodsFor: 'constants'!jupiter	^self new		x: 4.84143144246472090		y: -1.16032004402742839		z: -1.03622044471123109e-1		vx: 1.66007664274403694e-3 * self daysPerYear		vy: 7.69901118419740425e-3 * self daysPerYear		vz: -6.90460016972063023e-5 * self daysPerYear		mass: 9.54791938424326609e-4 * self solarMass! !!ShootoutBody class methodsFor: 'constants'!neptune	^self new		x: 1.53796971148509165e1		y: -2.59193146099879641e1		z: 1.79258772950371181e-1		vx: 2.68067772490389322e-3 * self daysPerYear		vy: 1.62824170038242295e-3 * self daysPerYear		vz: -9.51592254519715870e-5 * self daysPerYear		mass: 5.15138902046611451e-5 * self solarMass! !!ShootoutBody class methodsFor: 'constants'!pi	^3.141592653589793! !!ShootoutBody class methodsFor: 'constants'!saturn	^self new		x: 8.34336671824457987		y: 4.12479856412430479		z: -4.03523417114321381e-1		vx: -2.76742510726862411e-3 * self daysPerYear		vy: 4.99852801234917238e-3 * self daysPerYear		vz: 2.30417297573763929e-5 * self daysPerYear		mass: 2.85885980666130812e-4 * self solarMass! !!ShootoutBody class methodsFor: 'constants' stamp: 'eem 7/28/2008 12:42'!solarMass	^4.0 * self pi * self pi! !!ShootoutBody class methodsFor: 'constants'!sun	^self new		x: 0.0		y: 0.0		z: 0.0		vx: 0.0		vy: 0.0		vz: 0.0		mass: self solarMass! !!ShootoutBody class methodsFor: 'constants'!uranus	^self new		x: 1.28943695621391310e1		y: -1.51111514016986312e1		z: -2.23307578892655734e-1		vx: 2.96460137564761618e-3 * self daysPerYear		vy: 2.37847173959480950e-3 * self daysPerYear		vz: -2.96589568540237556e-5 * self daysPerYear		mass: 4.36624404335156298e-5 * self solarMass! !Object subclass: #ShootoutChameneosColour	instanceVariableNames: 'color'	classVariableNames: 'Blue Red Yellow'	poolDictionaries: ''	category: 'Shootout'!!ShootoutChameneosColour methodsFor: 'accessing'!color	^color! !!ShootoutChameneosColour methodsFor: 'accessing'!color: aColor	color := aColor! !!ShootoutChameneosColour methodsFor: 'as yet unclassified'!complementaryColourFor: aChameneosColour	"determine the complementary colour defined as..."	self == aChameneosColour ifTrue: [^self].	self isBlue		ifTrue:			[aChameneosColour isRed				ifTrue: [^self class yellow]				ifFalse: [^self class red]].	self isRed		ifTrue:			[aChameneosColour isBlue				ifTrue: [^self class yellow]				ifFalse: [^self class blue]].	aChameneosColour isBlue		ifTrue: [^self class red]		ifFalse: [^self class blue]! !!ShootoutChameneosColour methodsFor: 'testing'!hasSameColorAs: aChameneos	^self color == aChameneos color! !!ShootoutChameneosColour methodsFor: 'testing'!isBlue	^self == self class blue! !!ShootoutChameneosColour methodsFor: 'testing'!isRed	^self == self class red! !!ShootoutChameneosColour methodsFor: 'testing'!isYellow	^self == self class yellow! !!ShootoutChameneosColour methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self color! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutChameneosColour class	instanceVariableNames: ''!!ShootoutChameneosColour class methodsFor: 'accessing'!blue	^Blue! !!ShootoutChameneosColour class methodsFor: 'accessing'!blue: anObject	Blue := anObject! !!ShootoutChameneosColour class methodsFor: 'accessing'!red	^Red! !!ShootoutChameneosColour class methodsFor: 'accessing'!red: anObject	Red := anObject! !!ShootoutChameneosColour class methodsFor: 'accessing'!yellow	^Yellow! !!ShootoutChameneosColour class methodsFor: 'accessing'!yellow: anObject	Yellow := anObject! !!ShootoutChameneosColour class methodsFor: 'initialize-release'!createBlue	"comment stating purpose of message"	^super new color: #blue! !!ShootoutChameneosColour class methodsFor: 'initialize-release'!createRed	"comment stating purpose of message"	^super new color: #red! !!ShootoutChameneosColour class methodsFor: 'initialize-release'!createYellow	"comment stating purpose of message"	^super new color: #yellow! !!ShootoutChameneosColour class methodsFor: 'initialize-release'!initialize	"self initialize"	Red := self createRed.	Blue := self createBlue.	Yellow := self createYellow! !!ShootoutChameneosColour class methodsFor: 'printing'!generateReportOfColoursOn: readOut	| colours |	colours := Array				with: Blue				with: Red				with: Yellow.	colours do:			[:aColour |			colours do:					[:anotherColour |					aColour printOn: readOut.					readOut nextPutAll: ' + '.					anotherColour printOn: readOut.					readOut nextPutAll: ' -> '.					(aColour complementaryColourFor: anotherColour) printOn: readOut.					readOut nl]].	^readOut! !Object subclass: #ShootoutCreature	instanceVariableNames: 'creatureName colour selfMet creaturesMet'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutCreature methodsFor: 'accessing'!colour	^colour! !!ShootoutCreature methodsFor: 'accessing'!colour: anObject	colour := anObject! !!ShootoutCreature methodsFor: 'accessing'!creaturesMet	^creaturesMet! !!ShootoutCreature methodsFor: 'accessing'!creaturesMet: anObject	creaturesMet := anObject! !!ShootoutCreature methodsFor: 'accessing'!name	^creatureName! !!ShootoutCreature methodsFor: 'accessing'!name: anObject	creatureName := anObject! !!ShootoutCreature methodsFor: 'accessing'!selfMet	^selfMet! !!ShootoutCreature methodsFor: 'accessing'!selfMet: anObject	^selfMet := anObject! !!ShootoutCreature methodsFor: 'initialize-release'!initialize	selfMet := 0.	creaturesMet := 0! !!ShootoutCreature methodsFor: 'controlling'!visitMall: mall	[| partner |	partner := mall visitWith: self.	partner ifNotNil:			[colour := colour complementaryColourFor: partner colour.			self == partner ifTrue: [selfMet := selfMet + 1].			creaturesMet := creaturesMet + 1].	partner isNil]			whileFalse! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutCreature class	instanceVariableNames: ''!!ShootoutCreature class methodsFor: 'initialize-release' stamp: 'eem 8/1/2008 16:15'!withName: aName colour: aColour	^(ShootoutCreature new initialize)		name: aName;		colour: aColour! !Exception subclass: #ShootoutFastaReduxEnd	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!Object subclass: #ShootoutMall	instanceVariableNames: 'guard maxRendezvous open process queue cache pairCache'	classVariableNames: 'Units'	poolDictionaries: ''	category: 'Shootout'!!ShootoutMall methodsFor: 'controlling'!close	open := false! !!ShootoutMall methodsFor: 'controlling'!visitWith: aChameneos	| pair partner |	pair := self obtainPair.	pair me: aChameneos.	queue nextPut: pair.	pair wait.	partner := pair partner.	self releasePair: pair.	^partner! !!ShootoutMall methodsFor: 'initialize-release' stamp: 'eem 8/1/2008 16:14'!initialize	guard := Semaphore forMutualExclusion.	queue := SharedQueue new.	cache := OrderedCollection new.	1 to: 10 do: [:x | cache add: ShootoutPair new]! !!ShootoutMall methodsFor: 'initialize-release'!run	open := true.	process ifNil:			[process := [self processVisitors] newProcess.			process priority: Processor userBackgroundPriority -1 ].	process resume! !!ShootoutMall methodsFor: 'accessing'!maxRendezvous: max	maxRendezvous := max! !!ShootoutMall methodsFor: 'private'!obtainPair	^cache removeFirst! !!ShootoutMall methodsFor: 'private'!processVisitors	[open] whileTrue:			[1 to: maxRendezvous				do:					[:x |					| first second |					first := queue next.					second := queue next.					self setPartnersOn: first and: second.					first signal.					second signal].			[queue isEmpty] whileFalse: [queue next signal]].	process terminate.	process := nil! !!ShootoutMall methodsFor: 'private'!releasePair: pair	pair release.	cache addFirst: pair! !!ShootoutMall methodsFor: 'private'!setPartnersOn: first and: second	first partner: second me.	second partner: first me.! !!ShootoutMall methodsFor: 'private'!shutdown	[queue isEmpty] whileFalse: [queue next signal].	process terminate.	process := nil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutMall class	instanceVariableNames: ''!!ShootoutMall class methodsFor: 'initialize-release'!createAllowing: maxRendezvous	"Private"	^self basicNew initialize maxRendezvous: maxRendezvous! !!ShootoutMall class methodsFor: 'initialize-release' stamp: 'eem 8/1/2008 16:15'!createCreaturesWith: aCollectionOfColours	"Private"	| aName |	aName := 0.	^aCollectionOfColours collect:			[:aColour |			aName := aName + 1.			ShootoutCreature withName: aName colour: aColour]! !!ShootoutMall class methodsFor: 'initialize-release'!initialize	"self initialize"	Units := #('zero' 'one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine')! !!ShootoutMall class methodsFor: 'initialize-release'!new	^self shouldNotImplement! !!ShootoutMall class methodsFor: 'initialize-release'!openMallWith: aCollectionOfColours forNumberOfMeets: aNumber	| mall creatures guard |	mall := self createAllowing: aNumber.	mall run.	creatures := self createCreaturesWith: aCollectionOfColours.	guard := Semaphore new.	self		openMall: mall		forCreatures: creatures		usingGuard: guard.	self		waitForClosingOfMall: mall		withCreatures: creatures		usingGuard: guard.	^creatures! !!ShootoutMall class methodsFor: 'printing'!generateReportFor: creatures printOn: stream	| sum |	sum := creatures inject: 0 into: [:accum :each | accum + each creaturesMet].	creatures do:			[:aCreature |			aCreature creaturesMet printOn: stream.			stream				space;				nextPutAll: (self units at: aCreature selfMet + 1);				nl].	stream space.	sum printString		do: [:el | stream nextPutAll: (self units at: el digitValue + 1)]		separatedBy: [stream space].	^stream! !!ShootoutMall class methodsFor: 'printing'!generateReportForColours: colours printOn: stream	stream space.	colours do: [:colour | colour printOn: stream] separatedBy: [stream space].	^stream! !!ShootoutMall class methodsFor: 'private'!openMall: aMall forCreatures: creatures usingGuard: sema	| processes |	processes := creatures				collect: [:aCreature |					[aCreature visitMall: aMall.					sema signal] newProcess].	processes do:			[:proc |			proc priority: Processor userBackgroundPriority.			proc resume]! !!ShootoutMall class methodsFor: 'private'!waitForClosingOfMall: aMall withCreatures: creatures usingGuard: guard	creatures size timesRepeat: [guard wait].	aMall close! !!ShootoutMall class methodsFor: 'public' stamp: 'eem 8/1/2008 16:16'!runBenchMark: number on: anOutputStream	"self runBenchMark: 60000 on: Transcript."	| firstTestColours secondTestColours blue red yellow creatures |	blue := ShootoutChameneosColour blue.	red := ShootoutChameneosColour red.	yellow := ShootoutChameneosColour yellow.	firstTestColours := Array				with: blue				with: red				with: yellow.	secondTestColours := (OrderedCollection new)				add: blue;				add: red;				add: yellow;				add: red;				add: yellow;				add: blue;				add: red;				add: yellow;				add: red;				add: blue;				yourself.	(ShootoutChameneosColour generateReportOfColoursOn: anOutputStream) nl.	(self generateReportForColours: firstTestColours printOn: anOutputStream)		nl.	creatures := ShootoutMall openMallWith: firstTestColours forNumberOfMeets: number.	(self generateReportFor: creatures printOn: anOutputStream)		nl;		nl.	(self generateReportForColours: secondTestColours printOn: anOutputStream)		nl.	creatures := ShootoutMall openMallWith: secondTestColours forNumberOfMeets: number.	(self generateReportFor: creatures printOn: anOutputStream)		nl;		nl! !!ShootoutMall class methodsFor: 'accessing'!units	^Units! !Object subclass: #ShootoutMeteorBoard	instanceVariableNames: 'pieces ncol ncell twoRows sixRows oddRowsMask evenRowsMask southEdge eastEdge westEdge southToNorthMasks eastToWestMasks northWestMask northEastMask southWestMask southEastMask positionsPerPiece loopCount fillMask'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutMeteorBoard methodsFor: 'solving' stamp: 'nice 4/14/2012 16:52'!addPiece: aPiece index: pieceNumber forRow: iRow! !!ShootoutMeteorBoard methodsFor: 'solving' stamp: 'nice 4/4/2012 08:21'!boardStringWithPieces: pArray	| board |	board := String new: ncell.	1 to: pArray size do: [:i | | c |		c := '0123456789*' at: i.		(pArray at: i) fillSolution: board ncol: ncol withColor: c].	^board! !!ShootoutMeteorBoard methodsFor: 'solving' stamp: 'nice 4/14/2012 16:52'!removePiece: aPiece index: pieceNumber forRow: iRow! !!ShootoutMeteorBoard methodsFor: 'solving' stamp: 'nice 4/14/2012 23:56'!searchPuzzlesWithColorMask: colorMask boardMask: bMask rowOffset: rowOff pieces: pArray ifFound: solutionBlock	| nextFreeCell possibles colorBit iRow boardMask |	colorMask = 0 ifTrue: [ ^solutionBlock value: (self boardStringWithPieces: pieces) ].	loopCount := loopCount + 1.	boardMask := bMask.	iRow := rowOff.	[(nextFreeCell := (boardMask + 1) lowBit) > twoRows]		whileTrue:			[ iRow := iRow + 2.			boardMask := boardMask >> twoRows ].	possibles := (positionsPerPiece at: iRow // 2 + 1) at: nextFreeCell.	colorBit := 1.	1 to: pieces size do: [:pieceNumber |		(colorMask bitAnd: colorBit) = 0			ifFalse:				[ | positions |				positions := possibles at: pieceNumber.				1 to: positions size do: [:i |					| aPiece |					((aPiece := positions at: i) fitOnBoard: boardMask)						ifTrue:							[pieces at: pieceNumber put: (aPiece forRow: iRow).							self addPiece: aPiece index: pieceNumber forRow: iRow.							self searchPuzzlesWithColorMask: colorMask - colorBit boardMask: boardMask + aPiece mask rowOffset: iRow pieces: pArray ifFound: solutionBlock.							self removePiece: aPiece index: pieceNumber forRow: iRow]]].		colorBit := colorBit * 2].	^nil! !!ShootoutMeteorBoard methodsFor: 'solving' stamp: 'nice 4/14/2012 17:14'!solvedPuzzleDo: solutionBlock	loopCount := 0.	self		searchPuzzlesWithColorMask: 1 << pieces size - 1		boardMask: 0		rowOffset: 0		pieces: pieces copy		ifFound: [:aSolution |			solutionBlock value: aSolution; value: aSolution reversed].	^loopCount! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 3/30/2012 23:09'!canShiftE: aPieceMask	^(eastEdge bitAnd: aPieceMask) = 0! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 4/6/2012 09:21'!canShiftNE: aPieceMask	^(northEastMask bitAnd: aPieceMask) = 0! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 4/6/2012 09:21'!canShiftNW: aPieceMask	^(northWestMask bitAnd: aPieceMask) = 0! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 4/6/2012 09:21'!canShiftSE: aPieceMask	^(southEastMask bitAnd: aPieceMask) = 0! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 4/6/2012 09:21'!canShiftSW: aPieceMask	^(southEastMask bitAnd: aPieceMask) = 0! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 3/30/2012 23:09'!canShiftW: aPieceMask	^(westEdge bitAnd: aPieceMask) = 0! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 3/30/2012 22:59'!flip: aPieceMask	^self shiftSEmost: (southToNorthMasks		inject: 0 into: [:mask :rowMask |			mask << ncol + ((rowMask bitAnd: aPieceMask) >> (rowMask lowBit - 1))]) >> ncol! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 4/4/2012 03:56'!placesFor: aPieceMask do: aBlock	| westMask eastMask cellNumber |	eastMask := self shiftSEmost: aPieceMask.		[[westMask := eastMask.	[(cellNumber := westMask lowBit) > twoRows ifTrue: [^self].	(self hasEastOrWestIsland: westMask) ifFalse: [aBlock value: westMask].	self canShiftW: westMask] whileTrue: [westMask := self shiftW: westMask].	self canShiftNE: eastMask] whileTrue: [eastMask := self shiftNE: eastMask].	self canShiftNW: eastMask] whileTrue: [eastMask := self shiftNW: eastMask]! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 4/14/2012 23:15'!possiblePositionsOnTwoRows	^pieces collect: [:aPieceMask |		| possible iRot |		possible := (Array new: twoRows) collect: [:freeCell | Array new: 12 withAll: (ShootoutMeteorPiece new mask: 0)].		iRot := 0.		self rotationsOf: aPieceMask do: [:rotated |			iRot := iRot + 1.			self placesFor: rotated do: [:shifted |				(possible at: shifted lowBit) at: iRot put: (ShootoutMeteorPiece					mask: ((self hasEastOrWestIsland: shifted) ifTrue: [0] ifFalse: [shifted])					islands: (self islandsFor: (shifted bitOr: shifted - 1)))]].		possible]! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 4/6/2012 09:08'!rotate: aPieceMask	| rotatedMask pivot rotatedPivot irow row |	rotatedMask := 0.	irow := 1.	row := aPieceMask bitAnd: (southToNorthMasks at: irow).	rotatedPivot := pivot := 1 << (row highBit - 1).		[rotatedMask := rotatedMask + rotatedPivot.	[(row bitAnd: pivot - 1) = 0]		whileFalse:			[pivot := self shiftE: pivot.			rotatedPivot := self shiftNE: rotatedPivot.			(row bitAnd: pivot) = 0				ifFalse:					[rotatedMask := rotatedMask + rotatedPivot]].	(row := aPieceMask bitAnd: (southToNorthMasks at: (irow := irow + 1))) = 0]		whileFalse:			[(self canShiftNE: pivot)				ifTrue:					[pivot := self shiftNE: pivot.					rotatedPivot := self shiftNW: rotatedPivot]				ifFalse:					[pivot := self shiftNW: pivot.					rotatedPivot := self shiftW: rotatedPivot].			[row >= (pivot << 1)]				whileTrue:					[pivot := self shiftW: pivot.					(self canShiftSW: rotatedPivot)						ifFalse:							[rotatedPivot := rotatedPivot << twoRows.							rotatedMask := rotatedMask << twoRows.].					rotatedPivot := self shiftSW: rotatedPivot]].	^self shiftSEmost: rotatedMask! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 4/6/2012 09:03'!rotationsOf: aPieceMask do: aBlock	| next |	aBlock value: (next := aPieceMask); value: (self flip: next).	5 timesRepeat:  [aBlock value: (next := self rotate: next); value: (self flip: next)]! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 3/31/2012 00:13'!shiftE: aPieceMask	^aPieceMask >> 1! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 3/30/2012 23:15'!shiftNE: aPieceMask	| evens odds |	odds := oddRowsMask bitAnd: aPieceMask.	evens := evenRowsMask bitAnd: aPieceMask.	^odds >> 1 + evens << ncol! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 3/30/2012 23:15'!shiftNW: aPieceMask	| evens odds |	odds := oddRowsMask bitAnd: aPieceMask.	evens := evenRowsMask bitAnd: aPieceMask.	^evens << 1 + odds << ncol! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 3/30/2012 23:15'!shiftSE: aPieceMask	| evens odds |	odds := oddRowsMask bitAnd: aPieceMask.	evens := evenRowsMask bitAnd: aPieceMask.	^odds >> 1 + evens >> ncol! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 4/6/2012 09:09'!shiftSEmost: aPieceMask	| mostSEMask eastColumn lowBit |	aPieceMask odd ifTrue: [^aPieceMask].	lowBit := aPieceMask lowBit.	mostSEMask := aPieceMask >> (lowBit - 1 // twoRows * twoRows).	(mostSEMask bitAnd: southEdge) = 0		ifTrue: [mostSEMask := (self canShiftSE: mostSEMask)			ifTrue: [self shiftSE: mostSEMask]			ifFalse: [self shiftSW: mostSEMask]].	eastColumn := eastToWestMasks findFirst: [:e | (e bitAnd: mostSEMask) > 0].	^mostSEMask >> (eastColumn - 1)! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 3/30/2012 23:16'!shiftSW: aPieceMask	| evens odds |	odds := oddRowsMask bitAnd: aPieceMask.	evens := evenRowsMask bitAnd: aPieceMask.	^evens << 1 + odds >> ncol! !!ShootoutMeteorBoard methodsFor: 'generating' stamp: 'nice 3/31/2012 00:12'!shiftW: aPieceMask	^aPieceMask << 1! !!ShootoutMeteorBoard methodsFor: 'islands' stamp: 'nice 4/13/2012 13:43'!fillMaskStartingAt: pos stoppingAbove: maxCell ifFoundEnough: exitBlock	(fillMask bitAnd: pos) = 0 ifFalse: [^self].	(pos > maxCell) ifTrue: [^exitBlock value].	fillMask := fillMask + pos.	(self canShiftE: pos) ifTrue: [self fillMaskStartingAt: (self shiftE: pos) stoppingAbove: maxCell ifFoundEnough: exitBlock].	(self canShiftNE: pos) ifTrue: [self fillMaskStartingAt: (self shiftNE: pos) stoppingAbove: maxCell ifFoundEnough: exitBlock].	(self canShiftNW: pos) ifTrue: [self fillMaskStartingAt: (self shiftNW: pos) stoppingAbove: maxCell ifFoundEnough: exitBlock].	(self canShiftW: pos) ifTrue: [self fillMaskStartingAt: (self shiftW: pos) stoppingAbove: maxCell ifFoundEnough: exitBlock].	^self! !!ShootoutMeteorBoard methodsFor: 'islands' stamp: 'nice 4/7/2012 03:09'!findIsland: aMask	| nextFreeCellMask open |	nextFreeCellMask := 1 + aMask bitAnd: -1 - aMask.	fillMask :=  aMask.	open := false.	self fillMaskStartingAt: nextFreeCellMask stoppingAbove: 1 << (fillMask highBit - 1 // ncol * ncol - 1) ifFoundEnough: [open := true].	^open		ifTrue: [0]		ifFalse: [fillMask - aMask]! !!ShootoutMeteorBoard methodsFor: 'islands' stamp: 'nice 4/13/2012 13:50'!hasEastOrWestIsland: aMask	^ (self hasInsetZero: southEdge * (eastEdge bitAnd: aMask))		or: [(self hasInsetZero: southEdge * (westEdge bitAnd: aMask))			or: [(aMask bitAnd: eastEdge) > 0 and: [(aMask bitAnd: westEdge) > 0 and: [(self findIsland: aMask) bitCount \\ 5 > 0]]]]! !!ShootoutMeteorBoard methodsFor: 'islands' stamp: 'nice 3/31/2012 00:37'!hasInsetZero: aMask	| allOnes |	allOnes := aMask bitOr: aMask - 1.	^(allOnes bitAnd: allOnes + 1) > 0! !!ShootoutMeteorBoard methodsFor: 'islands' stamp: 'nice 4/13/2012 23:28'!hasNorthIsland: aPieceMask row: iRow	| bitReverse |	bitReverse := (#(-1 -1 6 4 2) at: iRow) * ncol.	^self hasSouthIsland: (aPieceMask bitReverse: bitReverse)! !!ShootoutMeteorBoard methodsFor: 'islands' stamp: 'nice 4/7/2012 00:52'!hasSouthIsland: aMask	^(self findIsland: aMask) bitCount \\ 5 > 0		or: [(self findIsland: fillMask) bitCount \\ 5 > 0]! !!ShootoutMeteorBoard methodsFor: 'islands' stamp: 'nice 4/13/2012 21:58'!islandsFor: aPieceMask	| islands aMask nextFreeCellMask open top |	islands := 0.	fillMask := aPieceMask.	top := 1 << (fillMask highBit - 1 // ncol * ncol - 1).	[(nextFreeCellMask := 1 + fillMask bitAnd: -1 - fillMask) <= top]		whileTrue:			[open := false.			aMask := fillMask.			self fillMaskStartingAt: nextFreeCellMask stoppingAbove: top ifFoundEnough: [open := true].			open ifFalse: [islands := islands + (fillMask - aMask)]].	^islands! !!ShootoutMeteorBoard methodsFor: 'islands' stamp: 'nice 4/15/2012 00:46'!northIslandsFor: aPieceMask row: iRow	| filled isleSEW bitReverse isleNE isleNW |	bitReverse := (#(-1 -1 6 4 2) at: iRow) * ncol.	filled := aPieceMask bitOr: aPieceMask - 1.	isleSEW := self islandsFor: filled.	(aPieceMask bitAnd: (eastEdge bitOr: westEdge)) = 0 ifFalse: [^isleSEW].	(isleSEW bitAnd: (eastEdge bitOr: westEdge)) = 0 ifFalse: [^isleSEW].	(southEdge bitAnd: aPieceMask) = 0		ifTrue: [filled := filled >> ncol << ncol].	isleNE := ((self islandsFor: (filled bitReverse: bitReverse)) bitReverse: bitReverse) bitOr: isleSEW.	isleNW := (1 << bitReverse - 1 - (isleNE bitOr: (aPieceMask bitOr: aPieceMask - 1))) bitOr: isleSEW.	^isleNW bitCount < isleNE bitCount		ifTrue: [isleNW]		ifFalse: [isleNE]! !!ShootoutMeteorBoard methodsFor: 'initialize-release' stamp: 'nice 4/7/2012 00:57'!fromString: aString	| rawString |	rawString := aString reject: [:e | e isSeparator].	ncell := rawString size.	ncol := (aString readStream upTo: Character cr) count: [:e | e isSeparator not].	twoRows := ncol * 2.	sixRows := ncol * 6.	self initializeRowColMasks.	pieces := rawString asSet asSortedArray collect: [:char |		self shiftSEmost:			(rawString inject: 0 into: [:pmask :c | pmask * 2 + (c = char ifTrue: [1] ifFalse: [0])])].	self initializePossiblePositions.! !!ShootoutMeteorBoard methodsFor: 'initialize-release' stamp: 'nice 4/14/2012 23:30'!initializePossiblePositions	| positionsPerPiecePerCell thePieceWhichBreakSymmetry |	positionsPerPiecePerCell := self possiblePositionsOnTwoRows.	thePieceWhichBreakSymmetry := (1 to: pieces size) detectMax: [:i | (positionsPerPiecePerCell at: i) detectSum: [:orientations | orientations count: [:e | e mask > 0]]].	positionsPerPiece := (1 to: 5) collect: [:iRow |		| maxMaskForRow northRow |		maxMaskForRow := (1 bitShift: (#(6 6 6 4 2) at: iRow) * ncol) - 1.		northRow :=  southEdge bitShift: ((#(-1 -1 6 4 2) at: iRow) - 1 * ncol).		(1 to: twoRows) collect: [:cellNumber |			(1 to: pieces size) collect: [:pieceNumber |				| orientations n |				orientations := (positionsPerPiecePerCell at: pieceNumber) at: cellNumber.				n := pieceNumber = thePieceWhichBreakSymmetry ifTrue: [6] ifFalse: [12].				Array new: n streamContents: [:str |					1 to: n do: [:i |						| aPiece |						aPiece := orientations at: i.						(aPiece mask > 0 and: [aPiece mask <= maxMaskForRow])							ifTrue:								[(iRow = 1 and: [cellNumber <= ncol])									ifTrue: [(self hasSouthIsland: aPiece mask)										ifFalse: [str nextPut: (ShootoutMeteorPiece mask: aPiece mask islands: 0)]]									ifFalse: [(aPiece mask bitAnd: northRow) > 0										ifTrue: [(self hasNorthIsland: aPiece mask row: iRow)											ifFalse:												[| isle |												isle := iRow = 5													ifTrue: [0]													ifFalse: [self northIslandsFor: aPiece mask row: iRow].												str nextPut: (ShootoutMeteorPiece mask: aPiece mask islands: isle)]]										ifFalse: [str nextPut: aPiece]]]]]]]]! !!ShootoutMeteorBoard methodsFor: 'initialize-release' stamp: 'nice 4/7/2012 00:58'!initializeRowColMasks	southEdge := 1 << ncol - 1.	southToNorthMasks := (0 to: 5) collect: [:i | southEdge << (ncol * i)].	eastEdge := 1<<sixRows-1/southEdge.	eastToWestMasks := (0 to: ncol - 1) collect: [:i | eastEdge << i].	westEdge := eastToWestMasks last.	oddRowsMask := 1<<sixRows-1/(1<<twoRows-1)*southEdge.	evenRowsMask := oddRowsMask << ncol.	northWestMask := westEdge bitAnd: evenRowsMask.	northEastMask := eastEdge bitAnd: oddRowsMask.	southWestMask := southEdge bitOr: (westEdge bitAnd: evenRowsMask).	southEastMask := southEdge bitOr: (eastEdge bitAnd: oddRowsMask).! !!ShootoutMeteorBoard methodsFor: 'printing' stamp: 'nice 4/7/2012 00:53'!printMask: aPieceMask	^String new: ncol * 2 + 1 * 6 streamContents: [:aStream | self printMask: aPieceMask on: aStream]! !!ShootoutMeteorBoard methodsFor: 'printing' stamp: 'nice 4/7/2012 00:53'!printMask: aPieceMask on: aStream	6 to: 1 by: -1 do: [:irow |		| mask |		irow odd ifTrue: [aStream space].		mask := 1 << (southToNorthMasks at: irow) highBit.		1 to: ncol do: [:icol |			aStream				nextPut: ((aPieceMask bitAnd: (mask := mask >> 1)) = 0					ifTrue: [$0]					ifFalse: [$1]);				space].		aStream cr]! !!ShootoutMeteorBoard methodsFor: 'printing' stamp: 'nice 5/16/2012 01:59'!printSolution: aString on: aStream	| src even |	src := aString readStream.	even := true.	[src atEnd]		whileFalse:			[(even := even not) ifTrue: [aStream space].			1 to: ncol do: [:j | aStream nextPut: src next; space].			aStream nl]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutMeteorBoard class	instanceVariableNames: ''!!ShootoutMeteorBoard class methodsFor: 'instance creation' stamp: 'nice 3/29/2012 00:01'!default	^self basicNew fromString:'0 0 0 0 1  2 2 2 0 1 2 6 6 1 1  2 6 1 5 5 8 6 5 5 5  8 6 3 3 3 4 8 8 9 3  4 4 8 9 3 4 7 4 7 9  7 7 7 9 9'! !!ShootoutMeteorBoard class methodsFor: 'instance creation' stamp: 'nice 5/16/2012 02:00'!solveDefault	^String streamContents: [:outputStream |		| board count minSolution maxSolution loopCount |		count := 0.		minSolution := String new: 50 withAll: $9.		maxSolution := String new: 50 withAll: $0.		loopCount := (board := self default) solvedPuzzleDo:			[:aString |					count := count + 1.					aString < minSolution ifTrue: [minSolution := aString].					aString > maxSolution ifTrue: [maxSolution := aString]].		outputStream print: loopCount; nextPutAll: ' loops'; nl;nl.		outputStream print: count; nextPutAll: ' solutions found'; nl; nl.		board printSolution: minSolution on: outputStream.		outputStream nl.		board printSolution: maxSolution on: outputStream.		outputStream nl]! !Morph subclass: #ShootoutMeteorBoardMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutMeteorBoardMorph methodsFor: 'accessing' stamp: 'nice 4/15/2012 00:04'!addPiece: aPiece index: pieceIndex forRow: row	| rgb hColor |	rgb := self rgbColorSpecs at: pieceIndex.	hColor := Color r: rgb first g: rgb second b: rgb third.	self fillMask: aPiece mask forRow: row withColor: hColor! !!ShootoutMeteorBoardMorph methodsFor: 'accessing' stamp: 'nice 4/15/2012 00:04'!fillMask: aPieceMask forRow: row withColor: hColor	| offset |	offset := row * 5.	aPieceMask bitsDo: [:k | (submorphs at: offset + k) fillColor: hColor].	self changed.! !!ShootoutMeteorBoardMorph methodsFor: 'accessing' stamp: 'nice 4/15/2012 00:04'!removePiece: aPiece index: pieceIndex forRow: row	self fillMask: aPiece mask forRow: row withColor: Color transparent! !!ShootoutMeteorBoardMorph methodsFor: 'accessing' stamp: 'nice 4/13/2012 23:19'!rgbColorSpecs	^#(		#(1.0  0.2  0.2)		#(0.0  1.0  0.0)		#(0.2  0.2  1.0)		#(1.0  1.0  0.0)		#(0.0  1.0  1.0)		#(0.8  0.2  0.8)		#(1.0  0.6  0.1)		#(0.6  0.1  0.1)		#(0.1  0.6  0.1)		#(0.1  0.1  0.6)		#(0.2  0.2  0.2)	)! !!ShootoutMeteorBoardMorph methodsFor: 'drawing' stamp: 'nice 4/14/2012 21:33'!drawOn: aCanvas! !!ShootoutMeteorBoardMorph methodsFor: 'initialize-release' stamp: 'nice 4/14/2012 16:14'!initialize	| cells center hexa x y |	super initialize.	cells := Array new: 50.	x := #(0 2 4 6 8 1 3 5 7 9).	y := (0 to: 9).	0 to: 49 do: [:i|		center := ((x at: 10 - (i \\ 10))*12+12) @ ((y at: 10 - (i // 5))*21+14).		hexa := ShootoutMeteorHexaMorph new.		hexa bounds: (center - (12@14) corner: center + (12@14)).		cells at: i + 1 put: hexa].	submorphs := cells.	bounds := cells inject: cells first bounds into: [:b :h | b merge: h bounds]! !Morph subclass: #ShootoutMeteorHexaMorph	instanceVariableNames: 'fillColor'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutMeteorHexaMorph methodsFor: 'initialize-release' stamp: 'nice 4/14/2012 15:54'!bounds: newBounds	bounds := (-12 @ -14 extent: 25@29) translateBy: newBounds center rounded.! !!ShootoutMeteorHexaMorph methodsFor: 'initialize-release' stamp: 'nice 4/14/2012 16:13'!initialize	super initialize.	bounds := 0@0 extent: 25@29.	fillColor := Color transparent! !!ShootoutMeteorHexaMorph methodsFor: 'drawing' stamp: 'nice 4/13/2012 15:28'!drawOn: aCanvas	aCanvas 		drawPolygon: (self vertices collect: [:e | e + self bounds center])		fillStyle: self fillColor		borderWidth: 1		borderColor: Color black! !!ShootoutMeteorHexaMorph methodsFor: 'accessing' stamp: 'nice 4/13/2012 15:29'!fillColor	^fillColor! !!ShootoutMeteorHexaMorph methodsFor: 'accessing' stamp: 'nice 4/13/2012 16:06'!fillColor: aColor	fillColor := aColor.	self changed! !!ShootoutMeteorHexaMorph methodsFor: 'accessing' stamp: 'nice 4/14/2012 10:38'!vertices	^{ 12 @ 7. 0 @ 14. -12 @ 7. -12 @ -7. 0 @ -14. 12 @ -7 }! !ShootoutMeteorBoard subclass: #ShootoutMeteorInstrumentedBoard	instanceVariableNames: 'boardMorph iFrame forMovie'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutMeteorInstrumentedBoard methodsFor: 'solving' stamp: 'nice 4/15/2012 01:30'!addPiece: aPiece index: pieceNumber forRow: iRow	boardMorph addPiece: aPiece index: pieceNumber forRow: iRow.	boardMorph world displayWorld.	forMovie		ifTrue: [self snapshotBoard]		ifFalse: [(Delay forMilliseconds: 200) wait].! !!ShootoutMeteorInstrumentedBoard methodsFor: 'solving' stamp: 'nice 4/15/2012 01:29'!removePiece: aPiece index: pieceNumber forRow: iRow	forMovie ifFalse: [(Delay forMilliseconds: 200) wait].	boardMorph removePiece: aPiece index: pieceNumber forRow: iRow.	boardMorph world displayWorld.	forMovie ifTrue: [self snapshotBoard]! !!ShootoutMeteorInstrumentedBoard methodsFor: 'solving' stamp: 'nice 4/15/2012 01:29'!snapshotBoard	iFrame := iFrame + 1.	boardMorph exportAsPNGNamed: 'meteor_' , (iFrame printPaddedWith: $0 to: 6) , '.png'! !!ShootoutMeteorInstrumentedBoard methodsFor: 'solving' stamp: 'nice 4/14/2012 17:34'!solvedPuzzleDo: solutionBlock	^[super solvedPuzzleDo: [:aSolution |			boardMorph flash.			(Delay forSeconds: 1) wait.			solutionBlock value: aSolution]]		ensure: [boardMorph delete]! !!ShootoutMeteorInstrumentedBoard methodsFor: 'initialize-release' stamp: 'nice 4/15/2012 01:08'!forMovie: aBoolean	forMovie := aBoolean.	iFrame := 0! !!ShootoutMeteorInstrumentedBoard methodsFor: 'initialize-release' stamp: 'nice 4/15/2012 01:06'!fromString: boardString	forMovie := false.	self initializeMorph.	super fromString: boardString.! !!ShootoutMeteorInstrumentedBoard methodsFor: 'initialize-release' stamp: 'nice 4/14/2012 16:43'!initializeMorph	boardMorph := ShootoutMeteorBoardMorph new.	boardMorph position: Display boundingBox center. "World cursorPoint."	boardMorph openInWorld.	"hexaBoard activeHand attachMorph: hexaBoard."! !Object subclass: #ShootoutMeteorPiece	instanceVariableNames: 'mask row'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutMeteorPiece methodsFor: 'accessing' stamp: 'nice 4/13/2012 21:53'!fillSolution: aString ncol: ncol withColor: c 	| offset |	offset := row * ncol.	mask bitsDo: [:k | aString at: offset + k put: c]! !!ShootoutMeteorPiece methodsFor: 'accessing' stamp: 'nice 4/4/2012 01:50'!mask	^mask! !!ShootoutMeteorPiece methodsFor: 'testing' stamp: 'nice 4/4/2012 02:09'!fitOnBoard: aBoardMask	^0 == (aBoardMask bitAnd: mask)! !!ShootoutMeteorPiece methodsFor: 'initialize-release' stamp: 'nice 4/4/2012 04:00'!forRow: rowOffset	row := rowOffset! !!ShootoutMeteorPiece methodsFor: 'initialize-release' stamp: 'nice 4/4/2012 01:50'!mask: aPieceMask	mask := aPieceMask! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutMeteorPiece class	instanceVariableNames: ''!!ShootoutMeteorPiece class methodsFor: 'instance creation' stamp: 'nice 4/4/2012 08:17'!mask: p islands: i	^i = 0		ifTrue: [ShootoutMeteorPiece new mask: p]		ifFalse: [ShootoutMeteorPieceWithIsland new mask: p; islands: i]! !ShootoutMeteorPiece subclass: #ShootoutMeteorPieceWithIsland	instanceVariableNames: 'islands aPieceCouldFitIntoIsland'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutMeteorPieceWithIsland methodsFor: 'testing' stamp: 'nice 4/4/2012 09:19'!fitOnBoard: aBoardMask	| occupied |	^0 == (aBoardMask bitAnd: mask) and:		[(occupied := aBoardMask bitAnd: islands) = islands			or: [aPieceCouldFitIntoIsland and: [(islands - occupied) bitCount = 5]]]! !!ShootoutMeteorPieceWithIsland methodsFor: 'initialize-release' stamp: 'nice 4/4/2012 09:16'!islands: islandMask	islands := islandMask.	aPieceCouldFitIntoIsland := islands bitCount >= 5! !Object subclass: #ShootoutNBodySystem	instanceVariableNames: 'bodies'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutNBodySystem methodsFor: 'nbody'!after: dt	1 to: bodies size do: [:i|		i+1 to: bodies size do: [:j|			(bodies at: i) and: (bodies at: j) velocityAfter: dt].	].	bodies do: [:each| each positionAfter: dt]! !!ShootoutNBodySystem methodsFor: 'nbody'!energy	| e |	e := 0.0.	1 to: bodies size do: [:i|		e := e + (bodies at: i) kineticEnergy.		i+1 to: bodies size do: [:j|			e := e - ((bodies at: i) potentialEnergy: (bodies at: j))].	].	^e! !!ShootoutNBodySystem methodsFor: 'initialize-release' stamp: 'eem 8/1/2008 16:08'!initialize	bodies := (OrderedCollection new		add: ShootoutBody sun; add: ShootoutBody jupiter; add: ShootoutBody saturn;		add: ShootoutBody uranus; add: ShootoutBody neptune; yourself) asArray.	bodies first offsetMomentum:		(bodies inject: (Array with: 0.0 with: 0.0 with: 0.0)			into: [:m :each | each addMomentumTo: m])! !Object subclass: #ShootoutPair	instanceVariableNames: 'partner me sema'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutPair methodsFor: 'initialize-release'!initialize	"Initialize a newly created instance. This method must answer the receiver."	partner := nil.	me := nil.	sema := Semaphore new.	^self! !!ShootoutPair methodsFor: 'initialize-release'!releasepartner:=nil.! !!ShootoutPair methodsFor: 'initialize-release'!signal	sema signal! !!ShootoutPair methodsFor: 'initialize-release'!wait	sema wait! !!ShootoutPair methodsFor: 'accessing'!me	^me! !!ShootoutPair methodsFor: 'accessing'!me: anObject	me := anObject! !!ShootoutPair methodsFor: 'accessing'!partner	^partner! !!ShootoutPair methodsFor: 'accessing'!partner: anObject	partner := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutPair class	instanceVariableNames: ''!!ShootoutPair class methodsFor: 'instance creation'!new	"Answer a newly created and initialized instance."	^super new initialize.! !!ShootoutPair class methodsFor: 'instance creation'!with: me	"Answer a newly created and initialized instance."self halt.	^super new initialize me: me! !Object subclass: #ShootoutPermGeneratorRedux	instanceVariableNames: 'timesRotated perm atEnd'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutPermGeneratorRedux methodsFor: 'accessing'!atEnd	^atEnd! !!ShootoutPermGeneratorRedux methodsFor: 'accessing'!next	| result |	result := perm copy.	self makeNext.	^result! !!ShootoutPermGeneratorRedux methodsFor: 'initialize-release' stamp: 'nice 1/22/2013 14:23'!initialize: size	perm := (1 to: size) asArray.	timesRotated := Array new: size withAll: 0.	atEnd := false.! !!ShootoutPermGeneratorRedux methodsFor: 'initialize-release'!makeNext	| temp remainder |	"* Generate the next permutation. *"	2 to: perm size do: [ :r |		"* Rotate the first r items to the left. *"		temp := perm at: 1.		1 to: r - 1 do: [ :i | perm at: i put: (perm at: i + 1) ].		perm at: r put: temp.		remainder := timesRotated at: r put: ((timesRotated at: r) + 1) \\ r.		remainder = 0 ifFalse: [ ^self ].		"* After r rotations, the first r items are in their original positions.		Go on rotating the first r+1 items. *"	].	"* We are past the final permutation. *"	atEnd := true! !!ShootoutPermGeneratorRedux methodsFor: 'benchmarks'!maxPfannkuchenTo: output	| max permutation checksum permCount flipsCount |	max := 0.	permCount := 0.	checksum := 0.	[self atEnd] whileFalse:		[permutation := self next.		permCount := permCount + 1.		(permCount = 1048576) ifTrue: [permCount := 0].		flipsCount := permutation pfannkuchen.		checksum := permCount odd ifTrue: [checksum+flipsCount] ifFalse: [checksum-flipsCount].		max := max max: flipsCount].	output print: checksum; nl.	^max! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutPermGeneratorRedux class	instanceVariableNames: ''!!ShootoutPermGeneratorRedux class methodsFor: 'instance creation'!new: size	^self new		initialize: size;		yourself! !Stream subclass: #ShootoutPiDigitSpigot	instanceVariableNames: 'numer accum denom k'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutPiDigitSpigot methodsFor: 'stream'!atEnd	^false! !!ShootoutPiDigitSpigot methodsFor: 'stream'!next	| digit |	[ self step. (digit := self extract) isNil ] whileTrue.	self eliminate: digit.	^digit! !!ShootoutPiDigitSpigot methodsFor: 'private'!eliminate: digit	accum := accum - (denom * digit).	accum := accum * 10.	numer := numer * 10! !!ShootoutPiDigitSpigot methodsFor: 'private'!extract	| tmp |	numer > accum ifTrue: [^nil].	tmp := numer + numer + numer + accum.	tmp \\ denom >= (denom - numer) ifTrue: [^nil].	^tmp // denom! !!ShootoutPiDigitSpigot methodsFor: 'private'!initialize	numer := denom := 1.	k := accum := 0.! !!ShootoutPiDigitSpigot methodsFor: 'private'!step	| y2 |	k := k + 1.	y2 := k * 2 + 1.	accum := (numer + numer + accum) * y2.	numer := numer * k.	denom := denom * y2.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutPiDigitSpigot class	instanceVariableNames: ''!!ShootoutPiDigitSpigot class methodsFor: 'instance creation'!new	^super basicNew initialize! !Object subclass: #ShootoutRandomNumber	instanceVariableNames: 'seed scale'	classVariableNames: 'FModulus Increment Modulus Multiplier'	poolDictionaries: ''	category: 'Shootout'!!ShootoutRandomNumber methodsFor: 'accessing'!next	seed := (seed * Multiplier + Increment) \\ Modulus.	^(seed * scale) / FModulus! !!ShootoutRandomNumber methodsFor: 'private'!to: anInteger	seed := 42.	scale := anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutRandomNumber class	instanceVariableNames: ''!!ShootoutRandomNumber class methodsFor: 'class initialization'!initialize	FModulus := 139968.0d0.	Increment := 29573.	Modulus := 139968.	Multiplier := 3877.! !!ShootoutRandomNumber class methodsFor: 'initialize-release'!to: anInteger	^self basicNew to: anInteger! !Object subclass: #ShootoutRandomNumberRedux	instanceVariableNames: 'seed scale multiplier increment modulus'	classVariableNames: 'FModulus Increment Modulus Multiplier'	poolDictionaries: ''	category: 'Shootout'!!ShootoutRandomNumberRedux methodsFor: 'accessing' stamp: 'nice 5/6/2012 16:21'!next   ^scale * (seed := seed * multiplier + increment \\ modulus)! !!ShootoutRandomNumberRedux methodsFor: 'private' stamp: 'nice 5/6/2012 16:21'!to: anInteger   seed := 42.   scale := anInteger / FModulus.   multiplier := Multiplier.   increment := Increment.   modulus := Modulus.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutRandomNumberRedux class	instanceVariableNames: ''!!ShootoutRandomNumberRedux class methodsFor: 'class initialization' stamp: 'nice 5/6/2012 16:21'!initialize   FModulus := 139968.0d0.   Increment := 29573.   Modulus := 139968.   Multiplier := 3877.! !!ShootoutRandomNumberRedux class methodsFor: 'instance creation'!to: anInteger   ^self basicNew to: anInteger! !ReadStream subclass: #ShootoutRepeatStream	instanceVariableNames: 'repeatPtr repeatLimit'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutRepeatStream methodsFor: 'testing'!atEnd	^repeatPtr >= repeatLimit! !!ShootoutRepeatStream methodsFor: 'accessing'!next	position >= readLimit ifTrue: [ self position: 0 ].	repeatPtr := repeatPtr + 1.	^collection at: (position := position + 1)! !!ShootoutRepeatStream methodsFor: 'initialize-release'!to: anInteger	repeatPtr := 0.	repeatLimit := anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutRepeatStream class	instanceVariableNames: ''!!ShootoutRepeatStream class methodsFor: 'instance creation'!to: anInteger on: aCollection	^(super on: aCollection) to: anInteger! !ShootoutRepeatStream subclass: #ShootoutRandomStream	instanceVariableNames: 'random percentages'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutRandomStream methodsFor: 'accessing'!next	| r |	r := random next.	repeatPtr := repeatPtr + 1.	1 to: percentages size do: [:i|		(r < (percentages at: i)) ifTrue: [^collection at: i]]! !!ShootoutRandomStream methodsFor: 'accessing'!random: aRandomNumber"* Share the random number generator so we can get the expected results. *"	random := aRandomNumber! !!ShootoutRandomStream methodsFor: 'initialize-release'!on: aCollection	| size cp |	repeatPtr := 0.	random := ShootoutRandomNumber to: 1.0d0.	size := aCollection size.	percentages := Array new: size.	collection := Array new: size.	cp := 0.0d0.	1 to: size do: [:i|		collection at: i put: (aCollection at: i) first.		percentages at: i put: (cp := cp + (aCollection at: i) last).	]! !ReadStream subclass: #ShootoutRepeatStreamRedux	instanceVariableNames: 'repeatPtr repeatLimit'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutRepeatStreamRedux methodsFor: 'accessing' stamp: 'nice 5/6/2012 16:15'!next   (repeatPtr := repeatPtr + 1) > repeatLimit ifTrue: [ShootoutFastaReduxEnd raise].   position >= readLimit ifTrue: [ self position: 0 ].   ^collection at: (position := position + 1)! !!ShootoutRepeatStreamRedux methodsFor: 'initialize-release'!to: anInteger   repeatPtr := 0.   repeatLimit := anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutRepeatStreamRedux class	instanceVariableNames: ''!!ShootoutRepeatStreamRedux class methodsFor: 'instance creation'!to: anInteger on: aCollection   ^(super on: aCollection) to: anInteger! !ShootoutRepeatStreamRedux subclass: #ShootoutRandomStreamRedux	instanceVariableNames: 'random percentages'	classVariableNames: 'LookupSize'	poolDictionaries: ''	category: 'Shootout'!!ShootoutRandomStreamRedux methodsFor: 'initialize-release'!cumulatedPercentagesFor: aCollection scale: scale   | size cp cumulatedPercentages |   size := aCollection size.   cumulatedPercentages := Array new: size.   cp := 0.0d0.   1 to: size do: [:i|      cumulatedPercentages at: i put: (cp := cp + (aCollection at: i) last) * scale.   ].   cumulatedPercentages at: size put: scale.  ^cumulatedPercentages! !!ShootoutRandomStreamRedux methodsFor: 'initialize-release' stamp: 'nice 5/6/2012 16:18'!on: aCollection   | size j cumulatedPercentages scale |   repeatPtr := 0.   size := LookupSize.   scale := size - 1.   random := ShootoutRandomNumberRedux to: scale.   cumulatedPercentages := self cumulatedPercentagesFor: aCollection scale: scale.   percentages := Array new: size.   collection := Array new: size.   j := 1.   1 to: size do: [:i |      [(cumulatedPercentages at: j) < (i - 1)] whileTrue: [j := j + 1].      collection at: i put: (aCollection at: j) first.      percentages at: i put: (cumulatedPercentages at: j).   ].! !!ShootoutRandomStreamRedux methodsFor: 'accessing' stamp: 'nice 5/6/2012 16:15'!next   | r i |   (repeatPtr := repeatPtr + 1) > repeatLimit ifTrue: [ShootoutFastaReduxEnd raise].   r := random next.   i := r truncated.   [r > (percentages at: (i := i + 1))] whileTrue.   ^collection at: i! !!ShootoutRandomStreamRedux methodsFor: 'accessing'!random	^random! !!ShootoutRandomStreamRedux methodsFor: 'accessing'!random: aRandomNumber   random := aRandomNumber! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutRandomStreamRedux class	instanceVariableNames: ''!!ShootoutRandomStreamRedux class methodsFor: 'class initialization'!initialize	LookupSize := 4 * 1024! !Object subclass: #ShootoutTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutTests class	instanceVariableNames: ''!!ShootoutTests class methodsFor: 'platform' stamp: 'eem 11/17/2008 12:37'!arg	3 to: 5 do:		[:i|		(SmalltalkImage current getSystemAttribute: i) ifNotNil:			[:aString|			aString asInteger ifNotNil:				[:arg| ^arg]]].	^nil! !!ShootoutTests class methodsFor: 'platform' stamp: 'nice 3/31/2012 01:43'!stdin	^StandardFileStream stdin! !!ShootoutTests class methodsFor: 'platform' stamp: 'nice 3/31/2012 01:42'!stdout	^StandardFileStream stdout! !!ShootoutTests class methodsFor: 'benchmark scripts'!binarytrees	self binarytrees: self arg to: self stdout.	^''! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'eem 8/1/2008 16:26'!chameneosredux2	self chameneosredux: self arg to: self stdout.	^''! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'eem 5/4/2010 11:46'!collectReferenceTimes	"Run the benchmarks 3 times and take their average, e.g. suitable	 for filling in values for referenceTimesForClosureInterpreter"	"ShootoutTests collectReferenceTimes"	| n refs |	Transcript clear.	n := 3.	refs := (1 to: n) collect: [:i| ShootoutTests runAllToInternalStream].	^{	refs.		(1 to: refs first size) collect:			[:i|			((refs inject: 0 into: [:sum :ref| (ref at: i) + sum]) / n) rounded] }! !!ShootoutTests class methodsFor: 'benchmark scripts'!fannkuchredux	| n f |	n := self arg.	f := self fannkuchRedux: n to: self stdout.	self stdout		nextPutAll: 'Pfannkuchen(', n printString, ') = ';		print: f; nl.	^''! !!ShootoutTests class methodsFor: 'benchmark scripts'!fasta	self fasta: self arg to: self stdout.	^''! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'nice 5/6/2012 16:16'!fastaredux   self fastaRedux: self arg to: self stdout.   ^''! !!ShootoutTests class methodsFor: 'benchmark scripts'!knucleotide4	self knucleotide4From: self stdin to: self stdout.	^''! !!ShootoutTests class methodsFor: 'benchmark scripts'!mandelbrot2	| n output |	n := self arg.	(output := self stdout)		nextPutAll: 'P4'; nl; print: n; space; print: n; nl;		binary.	self mandelbrot2: n to: output.	^''! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'nice 5/6/2012 22:14'!mandelbrot3   | n output |   n := self arg.   (output := self stdout)      nextPutAll: 'P4'; nl; print: n; space; print: n; nl;      binary.   self mandelbrot3: n to: output.   ^''! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'nice 5/6/2012 22:43'!meteor	self meteor: self arg to: self stdout.	^''! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'nice 5/6/2012 22:43'!nbody	self nbody: self arg to: self stdout.	^''! !!ShootoutTests class methodsFor: 'benchmark scripts'!pidigits4	self pidigitsTo: self arg width: 10 to: self stdout.	^''! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'eem 5/4/2010 11:44'!referenceTimesForClosureInterpreter	 "ClosureVM (QF 1.2.23 + Closure Bytecodes) on Eliot's 2010 vintage 2.66GHz Intel Core i7 MacBook Pro"	^Dictionary new		at: #nbody put: 4543;		at: #binarytrees put: 6944;		at: #chameneosredux put: 5799;		at: #threadring put: 5623;		yourself	 "ClosureVM (QF 1.2.23 + Closure Bytecodes) on Eliot's 2006 vintage 2.16GHz Intel Core Duo MacBook Pro"	"^Dictionary new		at: #nbody put: 7660;		at: #binarytrees put: 14417;		at: #chameneosredux put: 8478;		at: #threadring put: 8718;		yourself"! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'eem 6/24/2010 19:57'!referenceTimesForSqueakVM	 "Squeak VM (4.2.2beta1 + Closure Bytecodes) on Eliot's 2010 vintage 2.66GHz Intel Core i7 MacBook Pro"	^Dictionary new		at: #nbody put: 4917;		at: #binarytrees put: 8593;		at: #chameneosredux put: 5405;		at: #threadring put: 3789;		yourself! !!ShootoutTests class methodsFor: 'benchmark scripts'!regexdna	self regexDNA: self stdin contents to: self stdout.	^'' ! !!ShootoutTests class methodsFor: 'benchmark scripts'!revcomp	| input output |	input := self stdin.	output := self stdout.	#('ONE' 'TWO' 'THREE') do:		[:sequenceName|	| fasta |			fasta := self readFasta: sequenceName from: input.			self reverseComplement: fasta value named: fasta key to: output.		].	output flush. 	^'' ! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'eem 6/24/2010 20:01'!runAllToDummyStream	"Transcript clear.	 self runAllToDummyStream"	^self runAllToDummyStreamVs: self referenceTimesForClosureInterpreter! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'eem 6/24/2010 20:00'!runAllToDummyStreamVs: referenceTimes	"Transcript clear.	 self runAllToDummyStreamVs: self referenceTimesForClosureInterpreter"	"Transcript clear.	 self runAllToDummyStreamVs: self referenceTimesForSqueakVM"	| stream times ratios geometricMean |	stream := DummyStream new.	times := Array new writeStream.	ratios := Array new writeStream.	{ [self nbody: 200000 "20000000" to: stream].	   [self binarytrees: 15 to: stream].	   [self chameneosredux: 260000 to: stream].	   [self threadring: 10000000 to: stream] } do:		[:block | | benchmark reference t |		benchmark := (self selectorForSimpleBlock: block) copyUpTo: $:.		reference := referenceTimes at: benchmark asSymbol.		Smalltalk garbageCollect.		times nextPut: (t := Time millisecondsToRun: block).		ratios nextPut: t asFloat / reference.		self report: block decompile printString time: t reference: reference on: Transcript].	geometricMean := (ratios contents inject: 1 into: [:m :n| m * n]) raisedTo: 1 / ratios position.	Transcript		nextPutAll: 'geometric mean '; print: (geometricMean roundTo: 0.001);		nextPutAll: '   average speedup '; print: ((geometricMean - 1 * 100) roundTo: 0.01); nextPut: $%; cr; cr; flush.	^times contents! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'eem 6/24/2010 20:01'!runAllToInternalStream	"Transcript clear.	 self runAllToInternalStream"	^self runAllToInternalStreamVs: self referenceTimesForClosureInterpreter! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'eem 6/24/2010 19:59'!runAllToInternalStreamVs: referenceTimes	"Transcript clear.	 self runAllToInternalStreamVs: self referenceTimesForClosureInterpreter"	"Transcript clear.	 self runAllToInternalStreamVs: self referenceTimesForSqueakVM"	| stream times ratios geometricMean |	stream := (ByteString new: 10000) writeStream.	times := Array new writeStream.	ratios := Array new writeStream.	{ [self nbody: 200000 "20000000" to: stream].	   [self binarytrees: 15 to: stream].	   [self chameneosredux: 260000 to: stream].	   [self threadring: 10000000 to: stream] } do:		[:block | | benchmark reference t |		benchmark := (self selectorForSimpleBlock: block) copyUpTo: $:.		reference := referenceTimes at: benchmark asSymbol.		Smalltalk garbageCollect.		times nextPut: (t := Time millisecondsToRun: block).		ratios nextPut: t asFloat / reference.		self report: block decompile printString time: t reference: reference on: Transcript].	geometricMean := (ratios contents inject: 1 into: [:m :n| m * n]) raisedTo: 1 / ratios position.	Transcript		nextPutAll: 'geometric mean '; print: (geometricMean roundTo: 0.001);		nextPutAll: '   average speedup '; print: ((geometricMean - 1 * 100) roundTo: 0.01); nextPut: $%; cr; cr; flush.	^times contents! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'eem 6/24/2010 20:01'!runAllToTranscript	"Transcript clear.	 self runAllToTranscript"	^self runAllToTranscriptVs: self referenceTimesForClosureInterpreter! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'eem 6/24/2010 20:00'!runAllToTranscriptVs: referenceTimes	"Transcript clear.	 self runAllToTranscriptVs: self referenceTimesForClosureInterpreter"	"Transcript clear.	 self runAllToTranscriptVs: self referenceTimesForSqueakVM"	| times ratios geometricMean |	times := Array new writeStream.	ratios := Array new writeStream.	{ [self nbody: 200000 "20000000" to: Transcript].	   [self binarytrees: 15 to: Transcript].	   [self chameneosredux: 260000 to: Transcript].	   [self threadring: 10000000 to: Transcript] } do:		[:block | | benchmark reference t |		benchmark := (self selectorForSimpleBlock: block) copyUpTo: $:.		reference := referenceTimes at: benchmark asSymbol.		Smalltalk garbageCollect.		times nextPut: (t := Time millisecondsToRun: block).		ratios nextPut: t asFloat / reference.		self report: block decompile printString time: t reference: reference on: Transcript].	geometricMean := (ratios contents inject: 1 into: [:m :n| m * n]) raisedTo: 1 / ratios position.	Transcript		nextPutAll: 'geometric mean '; print: (geometricMean roundTo: 0.001);		nextPutAll: '   average speedup '; print: ((geometricMean - 1 * 100) roundTo: 0.01); nextPut: $%; cr; cr; flush.	^times contents! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'eem 10/30/2008 10:43'!selectorForSimpleBlock: aBlock	| is |	is := InstructionStream on: aBlock method.	is pc: aBlock startpc.	is scanFor:		[:x| | selectorOrScanner |		(selectorOrScanner := is selectorToSendOrSelf) ~~ is ifTrue:			[^selectorOrScanner].		false].	^nil! !!ShootoutTests class methodsFor: 'benchmark scripts'!spectralnorm2	self stdout print: (self spectralnorm: self arg) digits: 9; nl.	^''! !!ShootoutTests class methodsFor: 'benchmark scripts' stamp: 'eem 6/9/2009 12:30'!threadring  self threadring: self arg to: self stdout.   ^''! !!ShootoutTests class methodsFor: 'benchmarking' stamp: 'eem 8/1/2008 16:10'!binarytrees: n to: output	| minDepth maxDepth stretchDepth check longLivedTree iterations |	minDepth := 4.	maxDepth := minDepth + 2 max: n.	stretchDepth := maxDepth + 1.	check := (ShootoutTreeNode bottomUpTree: 0 depth: stretchDepth) itemCheck.	output		nextPutAll: 'stretch tree of depth '; print: stretchDepth; tab;		nextPutAll: ' check: '; print: check; nl.	longLivedTree := ShootoutTreeNode bottomUpTree: 0 depth: maxDepth.	minDepth to: maxDepth by: 2 do: [:depth|		iterations := 1 bitShift: maxDepth - depth + minDepth.		check := 0.		1 to: iterations do: [:i|			check := check + (ShootoutTreeNode bottomUpTree: i depth: depth) itemCheck.			check := check + (ShootoutTreeNode bottomUpTree: -1*i depth: depth) itemCheck			].		output			print:  (2*iterations); tab;			nextPutAll: ' trees of depth '; print: depth; tab;			nextPutAll: ' check: '; print: check; nl		].	output		nextPutAll: 'long lived tree of depth '; print: maxDepth; tab;		nextPutAll: ' check: '; print: longLivedTree itemCheck; nl! !!ShootoutTests class methodsFor: 'benchmarking' stamp: 'eem 8/1/2008 16:26'!chameneosredux: arg to: aStream	ShootoutMall runBenchMark: arg on: aStream! !!ShootoutTests class methodsFor: 'benchmarking'!fannkuchRedux: n to: output	^(ShootoutPermGeneratorRedux new: n) maxPfannkuchenTo: output! !!ShootoutTests class methodsFor: 'benchmarking'!fasta: n to: out	| r lineLength |	lineLength := 60.	self		writeFasta: 'ONE Homo sapiens alu'		from:			( ShootoutRepeatStream				to: n*2				on:'GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG',					'GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA',					'CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT',					'ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA',					'GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG',					'AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC',					'AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA' )		to: out		lineLength: lineLength.	r := ShootoutRandomNumber to: 1. "Shared random sequence"	self		writeFasta: 'TWO IUB ambiguity codes'		from:			(( ShootoutRandomStream				to: n*3				on: #(	#($a 0.27d0)						#($c 0.12d0)						#($g 0.12d0)						#($t 0.27d0)						#($B 0.02d0)						#($D 0.02d0)						#($H 0.02d0)						#($K 0.02d0)						#($M 0.02d0)						#($N 0.02d0)						#($R 0.02d0)						#($S 0.02d0)						#($V 0.02d0)						#($W 0.02d0)						#($Y 0.02d0)))			random: r;			yourself)		to: out		lineLength: lineLength.	self		writeFasta: 'THREE Homo sapiens frequency'		from:			(( ShootoutRandomStream				to: n*5				on: #(	#($a 0.3029549426680d0)						#($c 0.1979883004921d0)						#($g 0.1975473066391d0)						#($t 0.3015094502008d0)))				random: r;				yourself)		to: out		lineLength: lineLength.	out flush. ! !!ShootoutTests class methodsFor: 'benchmarking' stamp: 'nice 5/6/2012 16:17'!fastaRedux: n to: out   | lineLength iub sapiens |   lineLength := 60.   self      writeFastaRedux: 'ONE Homo sapiens alu'      from:         ( ShootoutRepeatStreamRedux            to: n*2            on:'GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG',               'GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA',               'CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT',               'ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA',               'GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG',               'AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC',               'AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA' )      to: out      lineLength: lineLength.   iub :=  ShootoutRandomStreamRedux            to: n*3            on: #(   #($a 0.27d0)                  #($c 0.12d0)                  #($g 0.12d0)                  #($t 0.27d0)                  #($B 0.02d0)                  #($D 0.02d0)                  #($H 0.02d0)                  #($K 0.02d0)                  #($M 0.02d0)                  #($N 0.02d0)                  #($R 0.02d0)                  #($S 0.02d0)                  #($V 0.02d0)                  #($W 0.02d0)                  #($Y 0.02d0)).   sapiens :=  ShootoutRandomStreamRedux            to: n*5            on: #(   #($a 0.3029549426680d0)                  #($c 0.1979883004921d0)                  #($g 0.1975473066391d0)                  #($t 0.3015094502008d0)).   sapiens random: iub random. "Share random sequence"   self      writeFastaRedux: 'TWO IUB ambiguity codes'      from: iub      to: out      lineLength: lineLength.   self      writeFastaRedux: 'THREE Homo sapiens frequency'      from: sapiens      to: out      lineLength: lineLength.   out flush.! !!ShootoutTests class methodsFor: 'benchmarking' stamp: 'nice 3/27/2012 21:50'!knucleotide4From: input to: output	"Same as 3a, but presize the frequency dictionary better"	| sequence writeFrequencies writeCount maxDictionarySize |	"ObjectMemory currentMemoryPolicy		memoryUpperBound: (640 bitShift: 20);		growthRegimeUpperBound: (512 bitShift: 20);		freeMemoryUpperBound: (64 bitShift: 20)."	sequence := (self readFasta: 'THREE' from: input) value asUppercase.	maxDictionarySize :=  sequence size min: 80000000.	writeFrequencies :=		[:k | | frequencies count |		frequencies := SortedCollection sortBlock: [:a :b|		(a value = b value) ifTrue: [b key < a key] ifFalse: [b value < a value]].	count := 0.0.	(sequence substringFrequencies3a: k using: (Dictionary new: ((4 raisedToInteger: k) * 3 / 2 min: maxDictionarySize)))		associationsDo: [:each|			frequencies add: each. count := count + each value].	frequencies do: [:each | | percentage |		percentage := (each value / count) * 100.0.		output			nextPutAll: each key; space;			print: percentage digits: 3; nl]].	writeCount := [:nucleotideFragment | | frequencies count |		frequencies := sequence substringFrequencies3a: nucleotideFragment size			using: (Dictionary new: ((4 raisedToInteger: nucleotideFragment size) min: sequence size) * 3 // 2).		count := frequencies at: nucleotideFragment ifAbsent: [0].		output print: count; tab; nextPutAll: nucleotideFragment; nl].	writeFrequencies value: 1. output nl.	writeFrequencies value: 2. output nl.	writeCount value: 'GGT'.	writeCount value: 'GGTA'.	writeCount value: 'GGTATT'.	writeCount value: 'GGTATTTTAATT'.	writeCount value: 'GGTATTTTAATTTATAGT'.! !!ShootoutTests class methodsFor: 'benchmarking'!mandelbrot2: extent to: output	| limit2 m bits zr zi cr ci i tr stepr stepi |	limit2 := 4.0d0.	m := 50.	stepr := 2.0d0 / extent.	stepi := 2.0d0 / extent.	0 to: extent - 1 do: [ :y |		 bits := 0.		 ci := stepi * y asFloat - 1.0d0.		 0 to: extent - 1 do: [ :x |			  cr := stepr * x asFloat - 1.5d0.			  zr := cr. zi := ci.			  bits := bits bitShift: 1.			  i := 1.  			  [					tr := (zr*zr) - (zi*zi) + cr.					zi := 2.0d0 * zr * zi + ci.					zr := tr.					(zr*zr) + (zi*zi) < limit2 and: [ (i := i + 1) < m ]			  ] whileTrue.			  i = m ifTrue: [ bits := bits + 1 ].			  (x bitAnd: 7) == 7 ifTrue: [					output nextPut: bits.					bits := 0.			  ]		 ]. 		 (extent bitAnd: 7) == 0 ifFalse: [			  bits := bits bitShift: 8 - (extent bitAnd: 7).			  output nextPut: bits.		 ]	]! !!ShootoutTests class methodsFor: 'benchmarking' stamp: 'nice 5/6/2012 22:14'!mandelbrot3: extent to: output   | bits zr zi zr2 zi2 cr ci i tr step reals imags |  step := 2.0d0 / extent.  reals := (0 to: extent - 1) collect: [:x | step * x - 1.5d0].  imags := (0 to: extent - 1) collect: [:y | step * y - 1.0d0].   1 to: extent do: [ :iy |       bits := 0.       ci := imags at: iy.       1 to: extent do: [ :ix |           cr := reals at: ix.           zr := cr. zi := ci.           zr2 := zr * zr. zi2 := zi * zi.           bits := bits bitShift: 1.           i := 1.             [               tr := zr2 - zi2 + cr.               zi := 2.0d0 * zr * zi + ci.               zr := tr.               (zr2 := zr*zr) + (zi2 := zi*zi) < 4.0d0 and: [ (i := i + 1) < 50 ]           ] whileTrue.           i = 50 ifTrue: [ bits := bits + 1 ].           (ix bitAnd: 7) == 0 ifTrue: [               output nextPut: bits.               bits := 0.           ]       ].        (extent bitAnd: 7) == 0 ifFalse: [           bits := bits bitShift: 8 - (extent bitAnd: 7).           output nextPut: bits.       ]   ]! !!ShootoutTests class methodsFor: 'benchmarking'!matchPatterns	^#(	'agggtaaa|tttaccct'			'[cgt]gggtaaa|tttaccc[acg]'			'a[act]ggtaaa|tttacc[agt]t'			'ag[act]gtaaa|tttac[agt]ct'			'agg[act]taaa|ttta[agt]cct'			'aggg[acg]aaa|ttt[cgt]ccct'			'agggt[cgt]aa|tt[acg]accct'			'agggta[cgt]a|t[acg]taccct'			'agggtaa[cgt]|[acg]ttaccct'	)! !!ShootoutTests class methodsFor: 'benchmarking' stamp: 'nice 5/16/2012 02:00'!meteor: nMax to: outputStream	| board count minSolution maxSolution |	count := 0.	minSolution := String new: 50 withAll: $9.	maxSolution := String new: 50 withAll: $0.	(board := ShootoutMeteorBoard default) solvedPuzzleDo:		[:aString |			count := count + 1.			aString < minSolution ifTrue: [minSolution := aString].			aString > maxSolution ifTrue: [maxSolution := aString]. ]. 	outputStream print: count; nextPutAll: ' solutions found'; nl; nl.	board printSolution: minSolution on: outputStream.	outputStream nl.	board printSolution: maxSolution on: outputStream.	outputStream nl.! !!ShootoutTests class methodsFor: 'benchmarking' stamp: 'eem 8/1/2008 16:09'!nbody: count to: output	| bodies |	bodies := ShootoutNBodySystem new initialize.	output print: bodies energy digits: 9; cr.	count timesRepeat: [bodies after: 0.01].	output print: bodies energy digits: 9; cr.	^''! !!ShootoutTests class methodsFor: 'benchmarking'!pidigitsTo: v width: width to: output	| n i pidigits |	n := v.	i := 0.	pidigits := ShootoutPiDigitSpigot new.	[n > 0] whileTrue:		[n < width			ifTrue:				[n timesRepeat: [output nextPut: (Character digitValue: pidigits next)].				n to: width do: [:each | output space].				i := i + n]			ifFalse:				[width timesRepeat: [output nextPut: (Character digitValue: pidigits next)].				i := i + width].		output tab; nextPut: $:; print: i; nl.		n := n - width]! !!ShootoutTests class methodsFor: 'benchmarking'!readFasta: sequenceName from: input	| prefix newline buffer description line char |	prefix := '>',sequenceName.	newline := Character cr.	"* find start of particular fasta sequence *"	[(input atEnd) or: [			(input peek = $>)				ifTrue: [((line := input upTo: newline)					indexOfSubCollection: prefix startingAt: 1) = 1]				ifFalse: [input skipThrough: newline. false]]		] whileFalse.	"* line-by-line read - it would be a lot faster to block read *"	description := line.	buffer := ReadWriteStream on: (String new: 1028).	[(input atEnd) or: [(char := input peek) = $>]] whileFalse: [		(char = $;)			ifTrue: [input upTo: newline]			ifFalse: [buffer nextPutAll: (input upTo: newline)]		].	^Association key: description value: buffer contents ! !!ShootoutTests class methodsFor: 'benchmarking'!regexDNA: sequence to: output	| s size1 size2 translation |	size1 := sequence size.	"* remove FASTA sequence descriptions and new-lines *"	s := sequence copyWithRegex: '>[^\r]*\r|\r' matchesReplacedWith: ''.	size2 := s size.	"* regex match *"	self matchPatterns do: [:each| 		output 			nextPutAll: each; space; 			print: (s occurrencesOfRegex: each); nl		]. 	"* regex substitution *"	translation := Dictionary new.	self substitutionPatterns do: [:each| 		translation at: each first put: each last].	s := s copyWithRegex: '[', 			(translation keys asArray fold: [:a :b| a, b]), ']'		matchesTranslatedUsing: [:l| translation at: l].	output		nl;		print: size1; nl; 		print: size2; nl; 		print: s size; nl! !!ShootoutTests class methodsFor: 'benchmarking'!reverseComplement: sequence named: sequenceName to: output	| complement newline lineLength n |	(sequenceName isNil) ifTrue: [^self].	complement := String new: 128 withAll: $*.	'ABCDGHKMNRSTVWY' with: 	'TVGHCDMKNYSABWR'		do: [:a :b|			complement at: a asInteger put: b.			complement at: a asLowercase asInteger put: b].	newline := Character lf.	lineLength := 60.	n := sequence size.	output nextPutAll: sequenceName; nextPut: newline.	[n > 0] whileTrue: [ 			1 to: ((n < lineLength) ifTrue: [n] ifFalse: [lineLength]) do:				[:i | output nextPut: 					(complement at: (sequence at: n - i + 1) asInteger)].			output nextPut: newline.			n := n - lineLength. 		] ! !!ShootoutTests class methodsFor: 'benchmarking'!spectralnorm: n	| u v vBv vv |	u := Array new: n withAll: 1.0d0.	10 timesRepeat:		[v := u multiplyAtAv.		 u := v multiplyAtAv].	vBv := 0.0d0.	vv := 0.0d0.	1 to: n do:		[:i |		 vBv := vBv + ((u at: i) * (v at: i)).		 vv := vv + ((v at: i) * (v at: i))].	^(vBv / vv) sqrt! !!ShootoutTests class methodsFor: 'benchmarking'!substitutionPatterns	^#(	#('B' '(c|g|t)')			#('D' '(a|g|t)')			#('H' '(a|c|t)')			#('K' '(g|t)')			#('M' '(a|c)')			#('N' '(a|c|g|t)')			#('R' '(a|g)')			#('S' '(c|g)')			#('V' '(a|c|g)')			#('W' '(a|t)')			#('Y' '(c|t)'))! !!ShootoutTests class methodsFor: 'benchmarking' stamp: 'eem 6/9/2009 12:25'!threadRing: aSemaphore output: output	| first last |	503 to: 1 by: -1 do: [:i|		first := ShootoutThread named: i next: first done: aSemaphore output: output.		last isNil ifTrue: [ last := first ].	].	last nextThread: first.	^first ! !!ShootoutTests class methodsFor: 'benchmarking' stamp: 'eem 6/9/2009 12:29'!threadring: arg to: output	| done |	(self threadRing: (done := Semaphore new) output: output) takeToken: arg.	done wait! !!ShootoutTests class methodsFor: 'benchmarking'!writeFasta: aString from: inStream to: outStream lineLength: lineLength	| i |	outStream nextPut: $>; nextPutAll: aString; nl.	i := 0.	[inStream atEnd] whileFalse:		[i == lineLength ifTrue: [outStream nl. i := 0].		outStream nextPut: inStream next.		i := i + 1].	outStream nl! !!ShootoutTests class methodsFor: 'benchmarking' stamp: 'nice 5/6/2012 16:15'!writeFastaRedux: aString from: inStream to: outStream lineLength: lineLength   | i |   outStream nextPut: $>; nextPutAll: aString; nl.   i := 0.  [ [      outStream nextPut: inStream next.     (i := i + 1) == lineLength ifTrue: [outStream nl. i := 0]   ] repeat ]         on: ShootoutFastaReduxEnd do: [:ignoreThisException | ].   i = 0 ifFalse: [outStream nl]! !!ShootoutTests class methodsFor: 'profiling' stamp: 'eem 10/16/2010 19:33'!profileAll	"self profileAll"	| stream |	stream := DummyStream new.	self nbody: 200000 "20000000" to: stream.	self binarytrees: 15 to: stream.	self chameneosredux: 260000 to: stream.	self threadring: 10000000 to: stream! !!ShootoutTests class methodsFor: 'reporting' stamp: 'eem 10/24/2008 16:44'!report: name time: millisecs reference: reference on: aStream	aStream		cr;		nextPutAll: name; cr;		nextPutAll: ' took '; print: millisecs / 1000.0; nextPutAll: ' seconds'; cr; flush;		nextPutAll: 'ratio: '; print: ((millisecs / reference) roundTo: 0.001);		nextPutAll: '   % change: '; print: ((millisecs - reference * 100 / reference) roundTo: 0.01); nextPut: $%;		cr; flush! !!ShootoutTests class methodsFor: 'squeak-ci' stamp: 'JMG 1/27/2013 22:17'!outputBenchmarkResults	| fstream results |	results := self runBenchmarksForCI.	fstream := FileDirectory default newFileNamed: 'results.jtl'.	[| xmlStream |	xmlStream := XMLWriter on: fstream.	xmlStream xmlDeclaration: '1.0' encoding: 'UTF-8'.	fstream cr.	xmlStream startTag: 'testResults';		 attribute: 'version' value: '1.2';		 endTag.	fstream cr.	xmlStream startTag: 'sample';		 attribute: 't' value: results asString;		 attribute: 'ts' value: Time millisecondClockValue asString;		 attribute: 's' value: 'true';		 attribute: 'lb' value: 'Binary Trees Benchmark';		 endTag.		xmlStream endTag: 'sample'.		fstream cr.	xmlStream endTag: 'testResults']		ensure: [fstream close]! !!ShootoutTests class methodsFor: 'squeak-ci' stamp: 'JMG 1/27/2013 22:18'!runBenchmarksForCI	| outstream total runs |	runs := 3.	total := 0. 	outstream := OrderedCollection new.	1 to: runs do: [:i | total := total + (Time millisecondsToRun: [self binarytrees: 10 to: (WriteStream on: outstream)]).].	^ (total / runs) asInteger.! !Object subclass: #ShootoutThread	instanceVariableNames: 'name nextThread token semaphore done output'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutThread methodsFor: 'accessing'!done: aSemaphore	done := aSemaphore ! !!ShootoutThread methodsFor: 'accessing'!fork	[ self run ] fork ! !!ShootoutThread methodsFor: 'accessing'!name: anInteger	name := anInteger ! !!ShootoutThread methodsFor: 'accessing'!nextThread: aThread	nextThread := aThread ! !!ShootoutThread methodsFor: 'accessing' stamp: 'eem 6/9/2009 12:26'!output: anObject	"Set the value of output"	output := anObject! !!ShootoutThread methodsFor: 'accessing' stamp: 'eem 6/9/2009 12:33'!run	[ self tokenNotDone ] whileTrue: [ nextThread takeToken: token - 1 ].	output print: name.	output name = 'stdout'	ifTrue: [output nl]	ifFalse: [output cr; flush].	done signal ! !!ShootoutThread methodsFor: 'accessing'!semaphore: aSemaphore	semaphore := aSemaphore ! !!ShootoutThread methodsFor: 'accessing'!takeToken: x	token := x.	semaphore signal ! !!ShootoutThread methodsFor: 'accessing'!tokenNotDone	semaphore wait.	^token > 0 ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutThread class	instanceVariableNames: ''!!ShootoutThread class methodsFor: 'instance creation' stamp: 'eem 6/9/2009 12:28'!named: anInteger next: aThread done: aSemaphore output: aStream	^self new name: anInteger; nextThread: aThread; done: aSemaphore; output: aStream; fork ! !!ShootoutThread class methodsFor: 'instance creation'!new	^self basicNew semaphore: Semaphore new ! !Object subclass: #ShootoutTreeNode	instanceVariableNames: 'left right item'	classVariableNames: ''	poolDictionaries: ''	category: 'Shootout'!!ShootoutTreeNode methodsFor: 'accessing'!itemCheck	^left isNil		ifTrue: [item] ifFalse: [item + (left itemCheck - right itemCheck)]! !!ShootoutTreeNode methodsFor: 'initialize-release'!left: leftChild right: rightChild item: anItem	left := leftChild.	right := rightChild.	item := anItem! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShootoutTreeNode class	instanceVariableNames: ''!!ShootoutTreeNode class methodsFor: 'instance creation'!bottomUpTree: anItem depth: anInteger	^(anInteger > 0)		ifTrue: [			self				left: (self bottomUpTree: 2*anItem - 1 depth: anInteger - 1)				right: (self bottomUpTree: 2*anItem depth: anInteger - 1) 				item: anItem			]		ifFalse: [self left: nil right: nil item: anItem]! !!ShootoutTreeNode class methodsFor: 'instance creation'!left: leftChild right: rightChild item: anItem	^(super new) left: leftChild right: rightChild item: anItem! !ShootoutChameneosColour initialize!ShootoutMall initialize!ShootoutRandomNumber initialize!ShootoutRandomNumberRedux initialize!ShootoutRandomStreamRedux initialize!